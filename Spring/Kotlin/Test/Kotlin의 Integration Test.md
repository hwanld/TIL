# Kotlin의 Integration Test
> [Kotlin의 Unit Test](https://github.com/hwanld/TIL/blob/main/Spring/Kotlin/Test/Kotlin%EC%9D%98%20Unit%20Test.md) 이후에 작성하는 글로, 라이브러리 등의 전반적인 셋팅은 위 글에 설명되어 있다. [2ntrip-Backend-Refactor](https://github.com/Entrip-Ajou/2ntrip-Backend-Refactor) 리펙토링 프로젝트를 진행하는 첫 번째 목표는 테스트 코드를 활용한 검증 및 TDD 기반 개발이었다. [RRB](https://github.com/ReRollBag/ReRollBag-BE) 프로젝트에서는 Java를 사용하여서 TDD까지 실습을 완료하였고, 이번에도 큰 무리 없이 할 수 있을 것이라고 생각했지만 **Kotlin 진영에서의 Test 코드 작성은 완전히 달랐기에**, 공부하고 그 내용을 남기는 바이다. 

<br>

Integration Test, 즉 통합 테스트는 이제껏 했던 모든 테스트를 종합적으로 사용하는 것으로, 실제 WAS를 띄워서 테스트 하는 방식으로 진행하였다. 따라서 `@SpringBootTest` 어노테이션을 사용해서 실제 WAS에서 테스트를 진행할 수 있도록 했다. 또한 TestRestTemplate가 아닌 `MockMvc를` 사용하였다.

또한 통합 테스트에서 많이들 간과하는 것이 `테스트용 DB 분리` 에 대해서 소홀하다는 것이다. 우리가 별 다른 조치를 취하지 않으면 테스트 코드는 `src/main/resources/` 안에 있는 프로퍼티들을 참조하는데, 이렇게 되면 로컬에서 실행하는 실제 DB와 동일한 DB로 테스트 코드가 작동하게 된다. 하지만 _AUTO_INCREMENT_ 와 같은 구조는 DB가 초기화 된 상태에서 실행되어야 바람직하다. 또한 해당 코드가 서버에서 돈다고 가정하면 아무리 @Transactional 어노테이션을 활용한다고 하더라도 실제 서비스 중인 서버의 DB에서 테스트를 진행하는 것은 많은 무리가 있다고 판단하여 `테스트 DB를 분리`하였다.

```kotlin
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.H2)
@ActiveProfiles("test")
class UsersIntegrationTest() : BehaviorSpec() {
    // 생략
}
```

어노테이션 구성은 그래서 다음과 같다. `@AutoConfigureTestDatabase` 어노테이션을 활용해서 테스트는 H2 데이터베이스를 사용할 수 있도록 하였다. 그리고 `@ActiveProfiles` 어노테이션을 활용해서, `src/test/resources/` 안의 프로퍼티들을 적용할 수 있도록 하였다. 그러고 src/test/resources/ 안의 프로퍼티들은 H2를 사용할 수 있도록 적용하였고, ddl-auto 옵션 역시 create를 사용하였다. 이런 방식으로 테스트를 진행하게 되면 매 번 테스트가 진행될 때 마다 테스트DB가 초기화되고 새로 실행되기 때문에` 테스트 코드가 메인 코드의 DB에 아무런 영향을 끼치지 않는 구조`로 만들 수 있다.

또한 주의해야 할 점이, 이런 식으로 테스트 DB를 분리시키게 되면 테스트 DB가 초기화 된 후 생성될 때 main 코드와는 다르게 `자동으로 테이블들을 만들어 주지 않는다는 것`이다. 따라서 테스트가 실행될 때 마다 테이블들을 생성하는 SQL을 실행해야 하는데, 다행히도 `src/test/resoucres/schema.sql` 파일을 생성해두면 해당 파일 내부의 모든 SQL을 테스트 DB의 초기화 및 생성과 동시에 실행해준다.

그럼 이런 SQL문을 어떻게 실행할 것인가 하는 답답함이 존재할 수 있는데, 이 역시도 쉽게 해결할 수 있다. main 코드의 .properties 파일에서` show-sql 옵션을 true`로 바꾼 다음, WAS를 실행시키면 처음 WAS가 뜰 때 테이블을 만드는 SQL문을 전부 `log`에 남겨 주는데, 이 log를 한 줄씩 복사해서 붙여넣으면 쉽게 적용할 수 있다.

```sql
// schema.sql

create sequence hibernate_sequence start with 1 increment by 1;
create table comments
(
    comment_id bigint generated by default as identity,
    author     varchar(255),
    content    varchar(255),
    plan_id    bigint,
    user_id    varchar(255),
    primary key (comment_id)
);
///생략
```
```groovy
# application-test.properties
# Local의 MySQL이 아닌 H2용 셋팅을 적용해준다.

spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.username=sa
spring.datasource.password=
spring.datasource.driver-class-name=org.h2.Driver
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
spring.datasource.hikari.jdbc-url=jdbc:h2:mem:testdb
spring.jpa.hibernate.ddl-auto=none

# 생략
```

이러한 부분을 제외하면 통합 테스트에서 크게 어려운 부분은 존재하지 않는다. WAS를 실제로 실행시키기 때문에 Spring의 Bean들이 전부 적용되기 때문에, 우리가 직접 값을 조절해야 하는 객체 (예를 들어서 테스트 대상은 아니지만 상황의 가정을 위해서 Repository에 저장을 해두어야 하는 상황 등) 들만 @Autowired 어노테이션을 통해서 생성해주고 나머지는 생성하지 않아도 알아서 Bean에 등록된다.

또한, 편의를 위해서 Logging을 적용했는데, kotlin에서의 Logging은 다양한 방법이 있겠지만 다음과 같이 사용하였다.
```kotlin
private final val logger = LoggerFactory.getLogger(UsersIntegrationTest::class.java)
```
그 외에 다른 부분들은 크게 어려운 점이 없었다. 추가로 Kotlin에서 다른 점이 있었는데, mockMvc의 경우 기존에는 .contentType().content().andExpect().andExpect() 와 같은 방식으로 작성하였지만, Kotlin의 DSL스러운 방법을 사용할 수 있었다.
```kotlin
mockMvc.post("/api/v2/users") {
    contentType = MediaType.APPLICATION_JSON
    content = objectMapper.writeValueAsString(usersSaveRequestDto)
}.andExpect {
    status { isOk() }
    content { json(objectMapper.writeValueAsString(successExpectedResponse)) }
}
```

그리고 보통 Json 파일을 String으로 바꾸거나 그 역을 ObjectMappper 객체를 자주 활용하는데, 테스트 코드를 짜던 중 아래와 같은 Json 파일을 고침에 있어 약간의 문제가 있었다.
```json
{
    "httpStatus" : 200,
    "messages" : "Success to Login",
    "data" : {
        accessToken : "AccessTokenValue",
        refreshToken : "RefreshTokenValue"
    }
}
```
위 파일을 응답으로 받았을 때, 우리는 여기서의 accessToken과 refreshToken의 값을 뜯어서 사용해야 하는 일이 있었는데, 응답으로 받은 위 파일은 json인데 반해 그 안의 data 필드에 들어있는 것은 json이 아닌 객체였다. 어떤 식으로 해결해야 하나 고민하고 있었는데, 다양한 방법이 있었지만 결국 우리는 다음과 같은 방식으로 진행하였다.

우선 받은 Json 객체를 서버에서 보낸 객체화하고 (ObjectMapper를 활용해서) 해당 객체의 data 필드 값을 String으로 변환하였다. 이후 String값에서 원하는 값들을 parsing하는 식으로 진행하였다. 물론 해당 방식이 좋은 방식은 아니지만, 메인 코드의 변형을 야기하지 않으며 사용할 수 있는 방법 중 가장 좋은 방법이 아니었나 싶다. 하지만 이런 식으로 값을 자주 꺼내서 사용해야 한다면 해당 방법 보다는 Gson이나 Serilizable과 같은 것을 사용하는 것이 옳다고 생각한다.

```kotlin
// 1. MockMvcResult의 response를 String (JSON)으로 바꾼다
val content = result.response.contentAsString

// 2. String (JSON)을 RestAPIMessages로 변환한다
val restAPIMessages = objectMapper.readValue<RestAPIMessages>(content, RestAPIMessages::class.java)

// 3. RestAPIMessages의 data 필드를 String으로 다시 변환한다
val str = restAPIMessages.data.toString()

// 4. String으로 바꾼 data 필드를 전처리해서 accessToken, refreshToken 값을 찾아낸다.
val pairs = str.substring(1, str.length - 1).split(", ")
for (pair in pairs) {
    val keyValue = pair.split("=")
    if (keyValue[0] == "accessToken") accessToken = keyValue[1]
    if (keyValue[0] == "refreshToken") refreshToken = keyValue[1]
}
```
전반적은 코드를 첨부하고, 글을 마치고자 한다. 코드는 일부만 작성되었고, 전체 코드는 [여기](https://github.com/Entrip-Ajou/2ntrip-Backend-Refactor/blob/feature/Users_REF-38/src/test/kotlin/com/entrip/Users/UsersIntegrationTest.kt)에서 확인할 수 있다.

```kotlin
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.H2)
@ActiveProfiles("test")
class UsersIntegrationTest() : BehaviorSpec() {

    override fun extensions() = listOf(SpringExtension)
    private final val logger = LoggerFactory.getLogger(UsersIntegrationTest::class.java)

    @Autowired
    lateinit var mockMvc: MockMvc

    @Autowired
    lateinit var usersRepository: UsersRepository

    @Autowired
    lateinit var plannersRepository: PlannersRepository

    final val user_id = "test@gmail.com"
    final val nickname = "testNickname"
    final val gender = 1
    final val photoUrl = "testPhotoUrl.com"
    final val password = "testPassword"
    final val tokenValue = "tokenValue"
    final val objectMapper = ObjectMapper().registerModule(KotlinModule())

    lateinit var accessToken: String
    lateinit var refreshToken: String

    init {
        beforeSpec {
            usersRepository.deleteAll()
            plannersRepository.deleteAll()
        }

        given("usersSaveRequestDto가 주어졌을 때") {
            val usersSaveRequestDto = UsersSaveRequestDto(
                user_id = user_id,
                nickname = nickname,
                gender = gender,
                password = password,
                photoUrl = photoUrl
            )
            val usersReturnDto = UsersReturnDto(
                user_id = user_id,
                nickname = nickname,
                gender = gender,
                photoUrl = photoUrl,
                token = null
            )

            val successExpectedResponse = RestAPIMessages(
                httpStatus = 200,
                message = "User is saved well",
                data = usersReturnDto
            )

            val failExpectedResponse = RestAPIMessages(
                httpStatus = 202,
                message = "NotAcceptedException\n",
                data = UsersReturnDto("", "", -1, "", "")
            )
            `when`("회원 가입을 요청하면") {
                then("회원 가입이 완료되고 usersReturnDto가 리턴된다") {
                    mockMvc.post("/api/v2/users") {
                        contentType = MediaType.APPLICATION_JSON
                        content = objectMapper.writeValueAsString(usersSaveRequestDto)
                    }.andExpect {
                        status { isOk() }
                        content { json(objectMapper.writeValueAsString(successExpectedResponse)) }
                    }
                }
            }
    // 생략  
}      
```

### REFERENCE
[스프링에서 코틀린 스타일 테스트 코드 작성하기](https://techblog.woowahan.com/5825/) <Br>
[Kotest Reference](https://kotest.io/docs/framework/framework.html) <br>
[MockMvc Kotlin DSL](https://www.baeldung.com/kotlin/mockmvc-kotlin-dsl) <br>