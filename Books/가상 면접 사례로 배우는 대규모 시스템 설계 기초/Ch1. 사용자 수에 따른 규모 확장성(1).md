_아래 글은 `가상 면접 사례로 배우는 대규모 시스템 설계 기초(알렉스 쉬 지음, 이병준 옮김, 인사이트 출판)` 을 보고 공부한 내용을 요약해서 남긴 글입니다. 지극히 주관적인 글이니 참고만 해 주시면 감사하겠습니다._

# Ch1. 사용자 수에 따른 규모 확장성(1)
## 데이터베이스
### 어떤 데이터베이스를 사용할 것인가?
데이터베이스는 크게 관계형 데이버베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)로 나눌 수 있다. 

* RDBMS : 관계형 데이터베이스, 자료를 테이블과 열, 칼럼으로 표현하며 SQL을 이용해 여러 테이블에 있는 데이터를 그 관계에 따라 조인(join)하여 합칠 수 있다.
* NoSQL : 비관계형 데이터베이스, 다시 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나뉜다. 일반적으로 조인 연산을 지원하지 않는다.

두 데이터베이스는 각각의 장단점을 가지고 있고, 이에 따라 상황에 맞게 사용하면 된다. 통상적으로 NoSQL을 사용하는 경우는 아래와 같다.
> 1. 아주 낮은 응답 지연시간 (latency)이 요구됨 
> 2. 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님
> 3. 데이터(JSON, YAML, XML 등)를 직렬화하거나 (serialize) 역직렬화(deserialize) 할 수 있기만 하면 됨
> 4. 아주 많은 양의 데이터를 저장할 필요가 있음.

NoSQL의 4가지 종류 중, 어떤 DB를 어떤 상황에 사용해야 하는지는 차후에 따로 정리하고자 한다.

<br>

## 수직적 규모 확장 vs 수평적 규모 확장
규모 확장에는 두 가지의 방법이 있는데, 하나는 `수직적 규모 확장(Scale up)` 이며 다른 하나는 `수평적 규모 확장(Scale out)`이다. 전자는 프로세스 서버에 고사양 자원을 추가하는 행위를 의미하고, 후자는 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다.

수직적 규모 확장의 경우 단순하고 편리하다는 가장 큰 장점이 있지만, 동시에 하나의 서버를 무한대로 증설할 수 없으며, 자동 복구 방안이나 다중화 방안을 제시하지 않는다. 하나의 서버가 다운되면 그대로 기능을 잃게 되는 것이다. 이러한 단점 때문에, 대규모 어플리케이션을 지원하는데는 수평적 규모 확장법이 적절하다.

한편, 하나의 서버에서 너무 많은 요청이 발생해 응답 속도가 느려지거나 접속이 불가능한 장애 상황이 발생할 수 있다. 또한 웹 서버가 다운되도 사용자는 서버를 사용할 수 없는데, 이러한 것을 해결하는데는 로드밸런서 (load balancer)를 도입하는 것이 최선이다.
### 로드밸런서
로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다. 
> public IP(88.88.88.1)로 요청을 보냄
> 
> 로드밸런서가 private IP로 변환함. 10.0.0.1 혹은 10.0.0.2와 같이 서버의 갯수에 따라서
> 
> 사용자의 요청은 하나의 IP(public IP)로 전달되지만 로드밸런서에 의해서 destination이 여러 갈래로 나뉘게 된다. (이때 더 나은 보안을 위해서 서버 간 통신에는 사설 IP주소 (private IP address)가 이용된다.)

이렇게 로드밸런서를 활용해서 부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면 장애를 자동복구하지 못하는 문제를 해소할 수 있고 동시에 웹 계층의 가용성을 향상시킬 수 있다. 기존의 트래픽은 2갈래로 나눠지기 때문에 한 대의 웹 서버에서는 트래픽이 절감되는 효과를 누릴 수 있다. 또한 하나의 웹 서버가 다운된다면, 다른 하나의 웹 서버로 트래픽을 전송해서 서비스 전체가 다운되는 일은 막을 수 있으며 다운된 웹 서버만 대체한다면 다시 원상복구가 가능하다.

### 데이터베이스 다중화
말 그대로 데이터베이스를 여러 개 사용하는 것을 의미한다. 보통은 서버 사이에 주(master)-부(slave) 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다.

쓰기 연산은 마스터에서만 지원하고, 부 데이터베이스에는 주 데이터베이스로부터 그 사본을 전달받으며 읽기 연산을 지원한다. 보통 쓰기 연산에 비해서 읽기 연산이 더욱 자주 일어나기 때문에, master는 하나만 사용하고 slave의 경우 복수 개를 사용한다. slave에서는 master에서 일어난 데이터의 변경을 전달받아 반영하는 식으로 이루어진다. 장점은 다음과 같다.

* 더 나은 성능 : 쓰기 연산은 주 데이터베이스 서버로만 요청하고, 읽기 연산은 부 데이터베이스 서버들로 분산되기 때문에 성능이 좋아진다.
* 안정성 : 데이터베이스 서버 일부가 자연재해 등의 이유로 정보를 모두 잃더라도, 데이터베이스 서버가 여러 곳에 분산되어 있기 때문에 비교적 안전하다.
* 가용성 : 데이터를 여러 지역에 복제해 두기 때문에 하나의 데이터베이스 서버가 사라지더라도 다른 데이터베이스로 대체가 가능하다. 

또한, master와 slave 서버가 각각 다운되었을 때 데이터베이스 다중화는 다음과 같이 대처할 수 있다.
* master가 다운 시 slave 중 하나가 master를 대체할 수 있다. slave가 하나라면 새롭게 바뀐 master에서 write, read 모두 수행하면 되고 여러 개의 slave가 있다면 slave 중 하나만 master의 역할을 대신 하면 된다.
* slave가 다운 시, slave가 하나라면 master가 slave의 read를 수행하면 된다. slave가 여러 개라면 다른 slave로 트래픽을 분산하면 간단하게 해결할 수 있다.
  
<br>

## 캐시
### 캐시 계층
컴퓨터 구조에서 배울 수 있는 캐시와 현재 다루고자 하는 캐시는 동일하다. 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소다. 예를 들어 하나의 데이터가 5번 호출되었을 때, DB를 5번 조회하는 것 보다 1번의 조회 이후 캐시에 저장해두고 나머지 4번의 조회는 캐시에서 조회해서 보여주는 것이 더욱 유리하다.

만약 하나의 데이터 조회 요청을 웹 서버가 받았다면, 우선 캐시를 확인한다. 캐시에 데이터가 있다면 해당 데이터를 반환하고 캐시에 데이터가 없다면 DB를 조회해서 값을 가져와 반환함과 동시에 캐시에도 저장한다. 이러한 캐시 전략을 읽기 주도형 캐시 전략(read-through caching strategy)라고 하는데, 이 외에도 다양한 캐시 전략이 있다.

### 캐시 사용 시 유의할 점
캐시 사용 시에는 아래 사항들을 고려해야 한다.

* 캐시는 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해볼 만하다.
* 캐시는 데이터를 휘발성 메모리에 두므로 (RAM), 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.
* 캐시에 보관된 데이터는 어떻게 만료(expire)되는가? 적당한 만료 정책을 수립해야 한다.
* 일관성(consistency)는 어떻게 유지되는가? 데이터 저장소의 원본과 캐시 내의 사본이 같은지 여부다.
* 장애는 어떻게 대처할 것인가?
* 캐시 메모리는 얼마나 크게 잡을 것인가?
* 데이터 방출 정책은 무엇인가? (LRU, FIFO 등)

