# MySQL Transaction and Lock
트랜잭션은 작업의 완전성을 보장해 주는 것이다. **논리적인 작업 셋(transaction)을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어 주는 기능**이다. 잠금과 트랜잭션은 서로 비슷한 개념 같지만 **잠금은 동시성을 제어하기 위한 기능**이고 **트랜잭션은 데이터의 정합성을 보장하기 위한 기능**이다. **잠금은 여러 커낵션에서 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할**을 한다. **격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨**을 의미한다.

## 1. Transaction
MySQL에서는 MyISAM이나 MEMORY 스토리지 엔진 또는 InnoDB 스토리지 엔진 등을 지원한다. 전자는 빠르지만 트랜잭션을 지원하지 않는 반면 후자는 트랜잭션을 지원한다. 우선 이 둘의 트랜잭션 처리 방식을 비교하고, 트랜잭션 사용 시 주의할 사항 역시 살펴보고자 한다.

### MySQL에서의 트랜잭션
**트랜잭션은 쿼리의 갯수와 상관 없이 하나의 논리적인 작업 셋 자체가 100% 적용되거나 (Commit) 아무것도 적용되지 않아야 (Rollback) 함을 보장해 주는 것이다.**

MyISAM과 InnoDB 두 환경에서 1,2,3 3개의 PK를 insert 했다고 가정해보자. 그리고 이때 DB에는 이미 3이라는 PK가 있다고 가정하자. 두 환경 모두 3이라는 Duplicate PK가 있다고 Error를 일으킬 것이다. MyISAM 환경에서는 1과 2는 insert 되는 것과는 달리 InnoDB에서는 1,2,3 모두 commit 되지 않는다. 

Memory 스토리지 엔진을 사용하는 테이블도 MyISAM과 동일하게 작동한다. InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 트랜잭션의 원칙대로 INSERT 문장을 실행하기 전으로 복구하였다. MyISAM 테이블에서 발생하는 이러한 현상을 부분 업데이트 (Partial Update) 라고 이야기하며, 이러한 부분 업데이트 현상은 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어 낸다.

트랜잭션이 지원되지 않는 엔진과 함께라면 트랜잭션 처리가 아주 골치아파 지게 되는데, 분기문을 사용해서 다음과 같이 처리할 수 있다.
```SQL
INSERT INTO tab_a ...;
If (_is_insert_1_succed) {
    INSERT INTO tab_b ...;
    If (_is_insert_2_succed) {
        // 처리 완료
    }ELSE{
        DELETE FROM tab_a WHERE ...;
        IF(_is_delete_succed){
            //처리 실패 및 tab_a, tab_b 모두 원상 복구 완료
        }ELSE{
            //해결 불가능한 심각한 상황 발생
        }
    }
}
```
MyISAM에 레코드를 INSERT를 할 떄는 위와 같이 하지 않으면 방법이 없다. 코드를 위와 같이 작성하지 않는다면 부분 업데이트의 결과로 쓰레기 데이터가 테이블에 남아 있을 가능성이 있다. 하지만 위의 코드를 InnoDB 테이블에서 처리한다고 가정하면 다음과 같은 간단한 코드로 완벽한 구현이 가능하다.
```SQL
try {
    START TRANSACTION;
    INSERT INTO tab_a ...;
    INSERT INTO tab_b ...;
    COMMIT;
} catch(exception) {
    ROLLBACK;
}
```

### 주의 사항
**트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.** 즉, 프로그램 코드에서 트랜잭션의 범위를 최소화하라는 의미이다. 다음 내용은 사용자가 게시판에 게시물을 작성한 후 저장 버튼을 클릭했을 때 서버에서 처리하는 내용을 순서대로 간단히 정리한 것이다.

> 1) 처리 시작
> *  데이터베이스 커넥션 생성
> * 트랜잭션 시작
> 2) 사용자의 로그인 여부 확인
> 3) 사용자의 글쓰기 내용의 오류 여부 확인
> 4) 첨부로 업로드된 파일 확인 및 저장
> 5) 사용자의 입력 내용을 DBMS에 저장
> 6) 첨부 파일 정보를 DBMS에 저장
> 7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
> 8) 게시물 등록에 대한 알림 메일 발송
> 9) 알림 메일 발송 이력을 DBMS에 저장
> * 트랜잭션 종료(COMMIT)
> * 데이터베이스 커넥션 반납
> 10) 처리 완료

위 처리 절차 중에서 DBMS의 트랜잭션 처리에 좋지 않은 영향을 미치는 부분을 나누어 살펴보자.

* 실제로 DBMS에서 데이터를 저장하는 작업은 5번부터 시작된다는 것을 알 수 있다. 그래서 아무리 빨리 처리되더라도 2번, 3번, 4번을 트랜잭션에 포함시킬 필요가 없다. 일반적인 데이터베이스 커넥션은 개수가 제한적이어서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질 수록 가용 커넥션 개수는 줄어들 것이다.
* 8번 작업에서 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게 해서든 DBMS의 트랜잭션 내에서 제거하는 것이 좋다. 프로그램이 실행되는 동안 메일 서버와 통신할 수 없는 상황이 발생한다면 웹 서버 및 DBMS 서버 모두에게 위험한 상황이 발생할 수 있다.
* 사용자가 입력한 정보를 저장하는 5번과 6번 작업은 반드시 하나의 트랜잭션으로 묶어야 하며, 7번 작업은 저장된 데이터의 단순 확인 및 조회이므로 트랜잭션에 포함할 필요는 없다. 9번은 이전의 트랜잭션과는 성격이 다르기 때문에, 별도의 트랜잭션으로 분리하는 것이 좋다.

위의 내용을 반영해서 서버에서 처리하는 방식을 바꾸면 다음과 같이 바꿀 수 있다.

> 1) 처리 시작
> 2) 사용자의 로그인 여부 확인
> 3) 사용자의 글쓰기 내용의 오류 여부 확인
> 4) 첨부로 업로드된 파일 확인 및 저장
> * 데이터베이스 커넥션 생성
> * 트랜잭션 시작
> 5) 사용자의 입력 내용을 DBMS에 저장
> 6) 첨부 파일 정보를 DBMS에 저장
> * 트랜잭션 종료(COMMIT)
> 7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
> 8) 게시물 등록에 대한 알림 메일 발송
> * 트랜잭션 시작
> 9) 알림 메일 발송 이력을 DBMS에 저장
> * 트랜잭션 종료(COMMIT)
> * 데이터베이스 커넥션 반납
> 10) 처리 완료

여기서 이야기 하고자 하는 것은 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 **트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화**해야 한다는 것이다. 또한 프로그램의 코드에서 라인 수는 한두 줄 이라고 하더라도 **네트워크 작업이 있는 경우에는 반드시 트랜잭션에 배제**해야 한다.

## 2. MYSQL Engine's Lock
MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다. MySQL 엔진은 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분으로 이해하면 되는데, MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다. MySQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락 이외에도 테이블의 구조를 잠그는 메타데이터 락(Metadata Lock) 그리고 사용자의 필요에 맞게 사용할 수 있는 네임드 락(Named Lock)이라는 잠금 기능도 제공한다. 이러한 잠금의 특징과 이러한 잠금이 어떤 경우에 사용되는지 살펴보고자 한다.

### Global Lock
글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금 가운데 가장 범위가 크다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL (Data Definition Language) 문장이나 DML (Data Manipulation Language) 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다. 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 DB가 다르더라도 동일하게 영향을 받는다. 

> 글로벌 락을 거는 `FLUSH TABLES WITH READ LOCK` 명령은 실행과 동시에 MySQL 서버 전체의 테이블을 닫고 잠금을 건다. 해당 명령이 실행되기 전에 테이블이나 레코드에 쓰기 잠금을 거는 SQL이 실행되었다면 먼저 실행된 SQL과 그 트랜잭션이 완료될 때 까지 기다려야 한다. 해당 명령은 테이블에 읽기 잠금을 걸기 전에 먼저 테이블을 플러시 해야 하기 때문에 테이블에 실행 중인 모든 종류의 쿼리가 완료돼야 한다. 그래서 장시간 SELECT 쿼리가 실행되고 있을 때는 `FLUSH TABLES WITH READLOCK` 명령은 SELECT 쿼리가 종료될 때까지 기다려야 한다.
>
> 해당 글로벌 락이 최악의 경우에는 MySQL 서버의 전체 모든 테이블에 대한 INSERT, UPDATE, DELETE 쿼리들이 실행되지 못하고 대기해야 하는 상황이 생길 수 있다. MySQL 서버의 모든 테이블에 큰 영향을 미치기 때문에 웹 서비스용으로 사용되는 MySQL 서버에는 가급적 사용하지 않는 것이 좋다. 또한 mysqldump 같은 백업 프로그램은 이 명령을 내부적으로 백업할 때도 있음으로, 해당 프로그램에서 사용하는 옵션에 따라 MySQL 서버에 어떤 잠근을 걸게 되는지 자세히 확인해보는 것이 좋다.

MySQL 서버가 업그레이드 되면서 MyISAM이나 MEMORY 스토리지 엔진 보다는 InnoDB 스토리지 엔진의 사용이 일반화됐다. InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다. 또한 MySQL 8.0 부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생겼다. MySQL 8.0 버전 부터는 Xtrabackup이나 Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.
```SQL
mysql> LOCK INSTANCE FOR BACKUP;
// 백업 실행
mysql> UNLOCK INSTANCE;
```
특정 세션에서 백업 락을 획득하면 모든 세션에서 다음과 같이 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.
* 데이터베이스 및 테이블 등 모든 객체 생성, 변경, 삭제
* REPAIR TABLE과 OPTIMIZE TABLE 명령
* 사용자 관리 및 비밀번호 변경

하지만 백업 락은 일반적인 테이블의 데이터 변경은 허용된다. 일반적으로 MySQL 서버의 구성은 소스 서버와 레플리카 서버로 구성되는데, 주로 백업은 레플리카에서 실행된다. 레플리카 서버에서 백업을 실행하는 도중에 소스 서버에 문제가 생기면 레플리카 서버의 데이터가최신 상태가 될 때까지 서비스를 멈춰야 할 수도 있다. 물론 XtraBackup이나 Enterprise Backup 툴이 실행되는 도중에 스키마 변경이 실행되면 백업은 실패하게 된다. 6~7시간을 들여 백업을 진행하고 있었으나 쿼리 한 줄 때문에 이를 다시 해야 하는 상황이 생기는 등의 문제가 있을 수 있기 때문에 백업 락이 도입됐으며, 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.

### Table Lock
테이블 락(Table Lock)은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다. 명시적으로는 `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 특정 테이블의 락을 획득할 수 있다. 명시적으로 획득한 잠금은 UNLOCK TABLES 명령으로 잠금을 반납(해제)할 수 있다. 명시적으로 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문에 특별한 상황이 아니면 어플리케이션에서 사용할 필요가 거의 없다.

묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. 즉, 쿼리가 실행되는 동안 자동으로 획득했다가 쿼리가 완료된 후 해체된다. 하지만 InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다. 더 정확히는 InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.

### Named Lock
네임드 락은 `GET_LOCK()` 함수를 통해 임의의 문자열에 대해 잠금을 설정할 수 있다. 이 잠금의 특징은 대상이 테이블이나 레코드 또는 `AUTO_INCREMENET`와 같은 데이터베이스 객체가 아니라는 것이다. 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다. 자주 사용되지는 않는다. 예를 들어, 데이터베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건처럼 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.

또한 네임드 락의 경우 많은 레코드에서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용될 수 있다. 배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되곤 한다. 각 프로그램의 실행 시간을 분산하거나 프로그램의 코드를 수정해서 데드락을 최소화할 수 는 있지만, 이는 간단한 방법이 아니며 완전한 해결책이 될 수 없다. 이러한 경우에 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 아주 간단해 해결할 수 있다.

### Metadata Lock
메타데이터 락은 데이터베이스 객체 (테이블이나 뷰)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다. 명시적으로 획득하거나 해제할 수 있는 것이 아니고 `RENAME TABLE tab_a TO tab_b`와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다. 

```SQL
mysql> RENAME TABLE rank TO rank_backup, rank_new TO rank;
```
위 명령문 처럼 한 번에 두 개의 테이블의 이름을 변경한다면 얻을 수 있는 이점이 있는데, 만약 두 테이블의 이름 변경을 두 개의 명령으로 나누어서 실행한다면, 아주 잠깐이지만 두 명령 사이에 "Table not found 'rank'"와 같은 상황이 발생할 수 있다. 하나의 명령문에 두 개의 작업을 동시에 실행한다면 이러한 문제를 해결할 수 있다.

메타데이터 잠금과 InnoDB의 트랜잭션을 동시에 사용해야 하는 경우도 있는데, 다음과 같은 테이블이 있다고 가정하자.
```SQL
mysql> CREATE TABLE access_log (
        id BIGINT NOT NULL AUTO_INCREMENT ,
        client_ip INT UNSIGNED ,
        access_dttm TIMESTAMP ,
        ...
        PRIMARY KEY(id)
    );
```
어느날 해당 테이블의 구조를 변경해야 할 요건이 발생했다고 하자. 만약 컬럼이 여러 개라고 가정한다면, MySQL 서버의 DDL은 단일 스레드로 작동하기 때문에 상당히 많은 소모 시간이 걸릴 것이다. 이때 새로운 구조의 테이블을 생성하고 먼저 최근의 데이터까지는 PK값을 범위 별로 나눠서 여러 개의 스레드로 빠르게 복사한다.

그리고 나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE 명령으로 응용 프로그램의 중단 없이 실행할 수 있다. "남은 데이터를 복사"하는 시간 동안은 테이블의 잠금으로 인해 INSERT를 할 수 없게 된다. 그래서 가능하면 미리 아주 최근 데이터까지 복사해 둬야 잠금 시간을 최소화해서 서비스에 미치는 영향을 줄일 수 있다.

## InnoDB 스토리지 엔진 잠금
InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. 레코드 기반의 잠금 방식 때문에 뛰어난 동시성 처리를 제공할 수 있지만 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다롭다.

하지만 최근 버전에서는 InnoDB의 트랜잭션과 잠금, 그리고 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입됐다. MySQL 서버의 information_schema 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 어ㄸ너 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있으며, 또한 장시간 잠금을 가지고 있는 클라이언트를 찾아서 종료시킬 수 있다. 또한 Performance Schema를 이용해 InnoDB 스토리지 엔진의 내부 잠금(Semaphore)에 대한 모니터링 방법도 추가됐다.

### InnoDB 스토리지 엔진의 잠금
InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)은 없다. 일반 상용 DBMS와는 조금 다르게 InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이라는 것이 존재한다.

1. 레코드 락

레코드 자체만을 잠그는 것을 레코드 락이라고 하며, 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다. 한 가지 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근 다는 것이다. 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다. 많은 사용자가 간과하는 부분이지만 레코드 자체를 잠그느냐, 아니면 인덱스를 잠그느냐는 상당히 크고 중요한 차이를 만들어 낸다.

InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용하지만 PK 또는 유니크 인덱스에 의한 변경 작업에서는 레코드 자체에 대해서만 락을 건다.

2. 갭 락
   
갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다. 갭 락은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것이다. 그 자체 보다는 넥스트 키 락의 일부로 자주 사용된다.

3. 넥스트 키 락

레코트 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다. 

4. 자동 증가 락

MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT 라는 칼럼 속성을 제공한다. 해당 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 일련번호 값을 지켜야 한다. InnoDB 엔진에르는 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 이용한다.

자동 증가 락은 새로운 레코드를 저장하는 쿼리에서만 필요하다. 트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다. AUTO_INCREMENT 락은 테이블에 단 하나만 존재하기 때문에 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 한다. (AUTO_INCREMENT 칼럼에 값을 명시하더라도 자동 증가 락은 걸리게 된다.)

AUTO_INCREMENT 락을 명시적으로 획득하고 해제하는 방법은 없다. 아주 짧은 시간 동안 걸렸다가 해제되는 잠금이라서 대부분의 경우 문제가 되지 않는다. 지금까지의 설명은 MySQL 5.0 이하 버전에서만 사용되던 방식이고, MySQL 5.1 이상부터는 innodb_autoinc_lock_mode라는 시스템 변수를 사용해 자동 증가 락의 작동 방식을 변경할 수 있다.

> * innodb_autoinc_lock_mode=0 <br>
> MySQL 5.0과 동일한 잠금 방식으로 모든 INSERT 문장은 자동 증가 락을 사용한다.
> * innodb_autoinc_lock_mode=1 <br>
> 단순히 한 건 또는 여러 건의 레코드를 INSERT하는 SQL 중에서 MySQL 서버가 INSERT되는 레코드 건수를 정확히 예측할 수 있을 때는 자동 증가 락(Auto increment lock)을 사용하지 않고, 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 처리한다. 개선된 래치는 자동 증가 락과 아주 짧은시간 동안만 잠금을 걸고 필요한 자동 증가 값을 가져오면 즉시 잠금이 해제된다. 하지만 서버가 건수를 예측할 수 없을 때는 MySQL 5.0과 동일하게 자동 증가 락을 사용한다. 이때는 INSERT 문장이 완료되기 전까지는 자동 증가 락은 해제되지 않기 때문에 다른 커넥션에서는 INSERT를 실행하지 못하고 대기하게 된다. 이렇게 대량 INSERT가 수행될 때는 InnoDB 엔진은 여러 개의 자동 증가 값을 한 번에 할당받아서 INSERT되는 레코드에 사용한다. 그래서 대량 INSERT되는 레코드는 자동 증가 값이 누락되지 않고 연속되게 INSERT된다. 하지만 한 번에 할당 받은 자동 증가 값이 남아서 사용되지 못하면 폐기하므로 대량 INSERT 문젱의 실행 이후에 INSERT되는 레코드의 자동 증가 값은 션속되지 않고 누락 값이 발생할 수 있다. 이 설정에서는 최소한 하나의 INSERT 문장으로 INSERT되는 레코드는 연속된 자동 증가 값을 가지게 된다. 그래서 이 설정 모드를 연속 모드라고도 한다.
>
> * innodb_autoinc_lock_mode=2 <br> 
> 이때 InnoDB 스토리지 엔진은 절대 자동 증가 락을 걸지 않고 경량화된 래치(뮤텍스)를 사용한다. 하지만 이 설정에서는 하나의 INSERT 문장으로 INSERT되는 레코드라고 하더라도 연속된 자동 증가 값을 보장하지는 않는다. 그래서 이 설정 모드를 인터리빙 모드라고도 한다. 이 설정 모드에서는 INSERT ... SELECT와 같은 대량 INSERT 문장이 실행되는 도중에도 다른 커넥션에서 INSERT를 수행할 수 있으므로 동시 처리 성능이 높아진다. 하지만 이 설정에서 작동하는 자동 증가 기능은 유니크한 값이 생성도니다는 것만 보장한다.

자동 증가 값이 한 번 증가하면 절대 줄어들지 않는 이유가 AUTO_INCREMENT 잠금을 최소화하기 위해서다. 설령 INSERT 쿼리가 실패했더라도 한 번 증가도니 AUTO_INCREMENT 값은 다시 줄어들지 않고 그대로 남는다.

### 인덱스와 잠금
위에서 언급한 바와 같이 InnoDB의 잠금은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식으로 처리한다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.

```SQL
// 데이터베이스의 employees 테이블에는 아래와 같이 first_name 컬럼만 멤버로 담긴 ix_firstname이라는 인덱스가 준비돼 있다.
// KEY ix_firstname (firstname)
// employees 테이블에서 first_name='Georgi'인 사원은 전체 253명이 있으며
// first_name='Gerogi'이며 last_name='Klassen'인 사원은 딱 1명만 있다.

UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
```
UPDATE 문장이 실행되면 단 1개의 레코드만 업데이트 될 것이다. 하지만 이 업데이트를 위해서 first_name='Georgi'인 253건의 레코드가 모두 잠기게 된다. MySQL이 인덱스를 잠그는 방식으로 처리하기 때문이다. 그럼 만약 인덱스가 하나도 없다면 어떻게 될까? 이러한 경우에는 테이블을 풀 스캔하면서 UPDATE 작업을 하는데, 이 과정에서 테이블에 있는 30여만 건의 모든 레코드를 잠그게 된다.

### 레코드 수준의 잠금 확인 및 해제
레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡하다. 테이블 잠금에서는 잠금의 대상이 테이블 자체이므로 쉽게 문제의 원인이 발견되고 해결되지만, 레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 잘 발견되지 않는다.


참조자료 : <br>
Real MySQL 8.0 (백은빈, 이성욱 지음. 위키북스)